<script>
  // === SCRIPT REWRITE FOR JS-DRIVEN ANIMATION ===

  // 화면 전환 관련 변수
  let currentScreen = 1;

  // 전역 변수
  let lastTableData = [];
  let lastTableData2 = [];
  let startTimeCache = {};
  const recentlyCalled = {}; // TTS 중복 호출 방지용 캐시

  // 시간 타이머 관리를 위한 전역 변수들
  let timeTimers = {}; // 각 검사별 타이머 ID 저장
  let cachedStartTimes = {}; // 각 검사별 시작 시간 캐시
  let currentElapsedTimes = {}; // 각 검사별 현재 경과 시간 저장

  // --- NEW: Blinking animation state and controller ---
  const blinkTimers = {};

  function startBlinking(elementId) {
    // If a timer already exists for this element, clear it to prevent duplicates
    if (blinkTimers[elementId]) {
      clearInterval(blinkTimers[elementId].timerId);
    }

    const station = document.getElementById(elementId);
    if (!station) return;

    // Find the elements to animate within this station
    const nextInfo = station.querySelector(".next-info");
    const nextLabel = station.querySelector(".next-label");
    const nextName = station.querySelector(".next-name");

    let isBlinked = false;
    let blinkCount = 0;
    const maxBlinks = 13; // Approx 10 seconds (13 * 800ms)

    // Immediately start in the blinked state
    isBlinked = true;
    blinkCount++;
    station.style.background =
      "linear-gradient(to bottom, #4c8fbd 0%, #2c5c8e 100%)";
    if (nextInfo) {
      nextInfo.style.background = "#ffffff";
      if (nextLabel) nextLabel.style.color = "#666666";
      if (nextName) nextName.style.color = "#2c5c8e";
    }

    const timerId = setInterval(() => {
      isBlinked = !isBlinked;
      blinkCount++;

      if (blinkCount > maxBlinks) {
        stopBlinking(elementId);
        return;
      }

      // Manually toggle styles
      if (isBlinked) {
        station.style.background =
          "linear-gradient(to bottom, #4c8fbd 0%, #2c5c8e 100%)";
        if (nextInfo) {
          nextInfo.style.background = "#ffffff";
          if (nextLabel) nextLabel.style.color = "#666666";
          if (nextName) nextName.style.color = "#2c5c8e";
        }
      } else {
        // Reset to default styles (let CSS classes take over)
        station.style.background = "";
        if (nextInfo) {
          nextInfo.style.background = "";
          if (nextLabel) nextLabel.style.color = "";
          if (nextName) nextName.style.color = "";
        }
      }
    }, 800);

    blinkTimers[elementId] = { timerId };
  }

  function stopBlinking(elementId) {
    if (blinkTimers[elementId]) {
      clearInterval(blinkTimers[elementId].timerId);
      delete blinkTimers[elementId];

      // Ensure styles are reset when blinking stops
      const station = document.getElementById(elementId);
      if (!station) return;
      const nextInfo = station.querySelector(".next-info");
      const nextLabel = station.querySelector(".next-label");
      const nextName = station.querySelector(".next-name");

      station.style.background = "";
      if (nextInfo) {
        nextInfo.style.background = "";
        if (nextLabel) nextLabel.style.color = "";
        if (nextName) nextName.style.color = "";
      }
    }
  }
  // --- END: Blinking animation controller ---

  // YouTube Player 설정
  let player;
  const soundMap = {
    A: "rvoCNw6ROnU", // ECG, Physical, Blood
    B: "7uCP_mq4XPM", // SNSB-C 1
    C: "oQZIW4RjCOM", // SNSB-C 2
    D: "LjrzAaGLUGU", // SNSB-C 3
  };
  const snsbcSoundMap = {
    "chldlsrb07@gmail.com": soundMap.B,
    "wjdgh7946@gmail.com": soundMap.C,
    "a93430506@gmail.com": soundMap.D,
  };

  // 설정 관리 시스템
  let settings = {
    soundSnsbc: true,
    ttsSnsbc: true,
    soundEcg: true,
    soundBlood: true,
    soundPhysical: true,
    ttsEcg: true,
    ttsBlood: true,
    ttsPhysical: true,
    enableAllSounds: true,
    enableAllTts: true,
  };

  // YouTube Player 초기화
  function onYouTubeIframeAPIReady() {
    player = new YT.Player("player", {
      height: "1",
      width: "1",
      events: {
        onReady: onPlayerReady,
      },
    });
  }

  function onPlayerReady(event) {
    event.target.setVolume(100);
  }

  function playSound(videoId) {
    if (player && typeof player.loadVideoById === "function") {
      player.loadVideoById(videoId);
    }
  }

  // 이름을 자연스럽게 발음하기 위한 텍스트 변환 함수
  function formatNameForTTS(name) {
    return `${name} 님. ${name} 님.`;
  }

  // Google Cloud TTS를 호출하여 음성을 재생하는 함수
  function speak(text) {
    const payload = text.startsWith("<speak>") ? text : formatNameForTTS(text);

    console.log("TTS 호출:", payload); // 디버깅용 로그

    google.script.run
      .withSuccessHandler(function (audioContent) {
        if (audioContent) {
          console.log("TTS 성공, 오디오 재생 시작");
          playAudioFromBase64(audioContent);
        } else {
          console.log("TTS 실패: 오디오 데이터 없음");
        }
      })
      .withFailureHandler(function (error) {
        console.error("TTS 에러:", error.message);
      })
      .getTTSAudioNew(payload);
  }

  // Base64로 인코딩된 오디오 데이터를 재생하는 함수
  function playAudioFromBase64(base64Data) {
    try {
      const audioSrc = `data:audio/mp3;base64,${base64Data}`;
      const audio = new Audio(audioSrc);
      audio.volume = 1.0;
      audio.play().catch((error) => {
        console.error("오디오 재생 실패:", error);
      });
    } catch (e) {
      console.error("오디오 재생 에러:", e);
    }
  }

  // 시작시간 파싱 함수
  function parseStartTime(str) {
    if (!str) return null;
    if (/^\d{1,2}:\d{2}:\d{2}$/.test(str)) {
      const now = new Date();
      const [h, m, s] = str.split(":").map(Number);
      return new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        h,
        m,
        s
      );
    }
    const d = new Date(str);
    if (!isNaN(d.getTime())) return d;
    return null;
  }

  // 경과시간 계산 함수
  function getElapsedTime(startTimeStr) {
    if (!startTimeStr) return "-";
    const startTime = parseStartTime(startTimeStr);
    if (!startTime) return "-";

    const now = new Date();
    const diff = Math.floor((now - startTime) / 1000);
    if (diff < 0) return "-";

    const m = Math.floor(diff / 60);
    const s = diff % 60;
    return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
  }

  // 새로운 시간 타이머 관리 함수들
  function startTimeTimer(testType, startTimeStr, elementId) {
    // 기존 타이머가 있으면 정리
    if (timeTimers[testType]) {
      clearInterval(timeTimers[testType]);
    }

    const startTime = parseStartTime(startTimeStr);
    if (!startTime) {
      currentElapsedTimes[testType] = "-";
      updateTimeDisplay(elementId, "-");
      return;
    }

    // 초기 경과 시간 계산
    const updateTime = () => {
      const now = new Date();
      const diff = Math.floor((now - startTime) / 1000);
      if (diff < 0) {
        currentElapsedTimes[testType] = "-";
        updateTimeDisplay(elementId, "-");
        return;
      }

      const m = Math.floor(diff / 60);
      const s = diff % 60;
      const timeStr = `${m.toString().padStart(2, "0")}:${s
        .toString()
        .padStart(2, "0")}`;
      currentElapsedTimes[testType] = timeStr;
      updateTimeDisplay(elementId, timeStr);
    };

    // 즉시 한 번 실행
    updateTime();

    // 1초마다 업데이트
    timeTimers[testType] = setInterval(updateTime, 1000);
  }

  function stopTimeTimer(testType) {
    if (timeTimers[testType]) {
      clearInterval(timeTimers[testType]);
      delete timeTimers[testType];
      delete currentElapsedTimes[testType];
      delete cachedStartTimes[testType];
    }
  }

  function updateTimeDisplay(elementId, timeStr) {
    const element = document.getElementById(elementId);
    if (element) {
      element.textContent = timeStr;
    }
  }

  // 시간 포맷팅 함수
  function formatTime(timeStr) {
    if (!timeStr) return "-";
    if (/^\d{1,2}:\d{2}:\d{2}$/.test(timeStr)) {
      return timeStr.substring(0, 5); // HH:mm만 표시
    }
    return timeStr;
  }

  // 설정 기반 사운드 재생
  function playSoundWithSettings(videoId, type = "general") {
    if (!settings.enableAllSounds) return;

    switch (type) {
      case "snsbc":
        if (!settings.soundSnsbc) return;
        break;
      case "ecg":
        if (!settings.soundEcg) return;
        break;
      case "blood":
        if (!settings.soundBlood) return;
        break;
      case "physical":
        if (!settings.soundPhysical) return;
        break;
    }

    playSound(videoId);
  }

  // 설정 기반 TTS 호출
  function speakWithSettings(text, type = "general") {
    if (!settings.enableAllTts) return;

    switch (type) {
      case "snsbc":
        if (!settings.ttsSnsbc) return;
        break;
      case "ecg":
        if (!settings.ttsEcg) return;
        break;
      case "blood":
        if (!settings.ttsBlood) return;
        break;
      case "physical":
        if (!settings.ttsPhysical) return;
        break;
    }

    speak(text);
  }

  // 화면 전환 함수
  function toggleScreen() {
    const screen1 = document.getElementById("screen1");
    const screen2 = document.getElementById("screen2");

    if (currentScreen === 1) {
      screen1.classList.remove("active");
      screen2.classList.add("active");
      currentScreen = 2;
      // 두 번째 화면 데이터 로드
      // Firebase 리스너가 자동으로 처리하므로 별도 호출 불필요
    } else {
      screen2.classList.remove("active");
      screen1.classList.add("active");
      currentScreen = 1;
      // 첫 번째 화면 데이터 로드
      // Firebase 리스너가 자동으로 처리하므로 별도 호출 불필요
    }
  }

  // 데이터 렌더링 함수 (첫 번째 화면용)
  function renderData(data) {
    const tableData = data.tableData;
    const nextUpData = data.nextUp;

    if (!tableData || tableData.length === 0) {
      return;
    }

    const idx = {
      이름: 0,
      ID: 1,
      심전도: 2,
      신체기능: 3,
      SNSBC: 4,
      심전도시작: 5,
      신체기능시작: 6,
      SNSBC시작: 7,
      수행자: 8,
      채혈: 9,
      채혈시작: 10,
      채혈종료: 11,
      채뇨: 12,
      신체계측: 13,
    };

    const prevDataMap = new Map(
      (window.lastTableData || []).map((row) => [row[1], row])
    );
    const currentData = tableData.slice(1);

    for (const currentRow of currentData) {
      const prevRow = prevDataMap.get(currentRow[1]);
      if (!prevRow) continue;

      // SNSB-C 완료
      if (prevRow[idx.SNSBC] === "검사중" && currentRow[idx.SNSBC] === "완료") {
        const performerEmail = currentRow[idx.수행자];
        const videoId = snsbcSoundMap[performerEmail];
        playSoundWithSettings(videoId, "snsbc");
        let roomNumber = 1;
        if (performerEmail === "wjdgh7946@gmail.com") roomNumber = 2;
        else if (performerEmail === "a93430506@gmail.com") roomNumber = 3;
        startBlinking(`room-${roomNumber}`);
        setTimeout(() => {
          if (
            nextUpData &&
            nextUpData.snsbc &&
            Array.isArray(nextUpData.snsbc) &&
            nextUpData.snsbc.length > 0
          ) {
            // 첫 번째 다음 대상자만 TTS 호명
            const nextPersonName = nextUpData.snsbc[0].replace(/<[^>]*>/g, "");
            const callKey = `snsbc-${nextPersonName}`;
            if (
              !recentlyCalled[callKey] ||
              new Date() - recentlyCalled[callKey] > 60000
            ) {
              speakWithSettings(nextPersonName, "snsbc");
              recentlyCalled[callKey] = new Date();
            }
          }
        }, 1000);
      }

      // 심전도 완료
      if (
        prevRow[idx.심전도] === "검사중" &&
        currentRow[idx.심전도] === "완료"
      ) {
        playSoundWithSettings(soundMap.A, "ecg");
        startBlinking("station-ecg");
        setTimeout(() => {
          if (nextUpData && nextUpData.ecg && nextUpData.ecg !== "-") {
            const nextPersonName = nextUpData.ecg.replace(/<[^>]*>/g, "");
            const callKey = `ecg-${nextPersonName}`;
            if (
              !recentlyCalled[callKey] ||
              new Date() - recentlyCalled[callKey] > 60000
            ) {
              speakWithSettings(
                `<speak>다음 심전도, <break time="0.3s"/> ${nextPersonName} 님. <break time="0.3s"/> ${nextPersonName} 님.</speak>`,
                "ecg"
              );
              recentlyCalled[callKey] = new Date();
            }
          }
        }, 1000);
      }
      // 신체기능 완료
      if (
        prevRow[idx.신체기능] === "검사중" &&
        currentRow[idx.신체기능] === "완료"
      ) {
        playSoundWithSettings(soundMap.A, "physical");
        startBlinking("station-physical");
        setTimeout(() => {
          if (
            nextUpData &&
            nextUpData.physical &&
            nextUpData.physical !== "-"
          ) {
            const nextPersonName = nextUpData.physical.replace(/<[^>]*>/g, "");
            const callKey = `physical-${nextPersonName}`;
            if (
              !recentlyCalled[callKey] ||
              new Date() - recentlyCalled[callKey] > 60000
            ) {
              speakWithSettings(
                `<speak>다음 신체기능, <break time=\"0.3s\"/> ${nextPersonName} 님. <break time=\"0.3s\"/> ${nextPersonName} 님.</speak>`,
                "physical"
              );
              recentlyCalled[callKey] = new Date();
            }
          }
        }, 1000);
      }
      // 채혈 완료
      if (prevRow[idx.채혈] === "검사중" && currentRow[idx.채혈] === "완료") {
        playSoundWithSettings(soundMap.A, "blood");
        startBlinking("station-blood");
        setTimeout(() => {
          if (nextUpData && nextUpData.blood && nextUpData.blood !== "-") {
            const nextPersonName = nextUpData.blood.replace(/<[^>]*>/g, "");
            const callKey = `blood-${nextPersonName}`;
            if (
              !recentlyCalled[callKey] ||
              new Date() - recentlyCalled[callKey] > 60000
            ) {
              speakWithSettings(
                `<speak>다음 채혈, <break time=\"0.3s\"/> ${nextPersonName} 님. <break time=\"0.3s\"/> ${nextPersonName} 님.</speak>`,
                "blood"
              );
              recentlyCalled[callKey] = new Date();
            }
          }
        }, 1000);
      }
    }

    window.lastTableData = currentData;

    const examRooms = {
      "room-1": { current: "-", time: "-", active: false, startTime: null },
      "room-2": { current: "-", time: "-", active: false, startTime: null },
      "room-3": { current: "-", time: "-", active: false, startTime: null },
    };
    const testStations = {
      ecg: {
        current: "-",
        time: "-",
        next: "-",
        active: false,
        startTime: null,
      },
      blood: {
        current: [],
        time: "-",
        next: "-",
        active: false,
        startTime: null,
      },
      physical: {
        current: "-",
        time: "-",
        next: "-",
        active: false,
        startTime: null,
      },
    };

    for (let i = 1; i < tableData.length; i++) {
      const row = tableData[i];
      const name = row[idx.이름].replace(
        /<span class="status-dot [^"]*"><\/span> /,
        ""
      );
      if (row[idx.SNSBC] === "검사중" && row[idx.수행자]) {
        const performerEmail = row[idx.수행자];
        let roomNumber = 1;
        if (performerEmail === "wjdgh7946@gmail.com") roomNumber = 2;
        if (performerEmail === "a93430506@gmail.com") roomNumber = 3;
        const roomKey = `room-${roomNumber}`;
        examRooms[roomKey] = {
          current: name,
          time: getElapsedTime(row[idx.SNSBC시작]),
          active: true,
          startTime: row[idx.SNSBC시작],
        };
      }
      if (row[idx.심전도] === "검사중") {
        testStations.ecg.current = name;
        testStations.ecg.time = getElapsedTime(row[idx.심전도시작]);
        testStations.ecg.active = true;
        testStations.ecg.startTime = row[idx.심전도시작];
      }
      if (row[idx.채혈] === "검사중") {
        testStations.blood.current.push(name);
        testStations.blood.time = getElapsedTime(row[idx.채혈시작]);
        testStations.blood.active = true;
        testStations.blood.startTime = row[idx.채혈시작];
      }
      if (row[idx.신체기능] === "검사중") {
        testStations.physical.current = name;
        testStations.physical.time = getElapsedTime(row[idx.신체기능시작]);
        testStations.physical.active = true;
        testStations.physical.startTime = row[idx.신체기능시작];
      }
    }

    if (nextUpData) {
      testStations.ecg.next = nextUpData.ecg || "-";
      testStations.blood.next = nextUpData.blood || "-";
      testStations.physical.next = nextUpData.physical || "-";
    }

    updateExamRooms(examRooms);
    updateTestStations(testStations);
    updateNextSubject(nextUpData);
  }

  function updateExamRooms(rooms) {
    Object.keys(rooms).forEach((roomKey) => {
      const room = document.getElementById(roomKey);
      const currentEl = document.getElementById(`${roomKey}-current`);
      const timeEl = document.getElementById(`${roomKey}-time`);
      const roomData = rooms[roomKey];

      currentEl.textContent = roomData.current;

      // 시간 타이머 관리
      if (roomData.active && roomData.startTime) {
        // 시작 시간이 변경되었는지 확인
        if (cachedStartTimes[roomKey] !== roomData.startTime) {
          cachedStartTimes[roomKey] = roomData.startTime;
          startTimeTimer(roomKey, roomData.startTime, `${roomKey}-time`);
        }
      } else {
        // 검사가 끝났으면 타이머 정리
        stopTimeTimer(roomKey);
        timeEl.textContent = "-";
      }

      room.classList.remove("active");
      if (roomData.active) {
        room.classList.add("active");
      }
    });
  }

  function updateTestStations(stations) {
    Object.keys(stations).forEach((stationKey) => {
      const station = document.getElementById(`station-${stationKey}`);
      const currentEl = document.getElementById(`${stationKey}-current`);
      const timeEl = document.getElementById(`${stationKey}-time`);
      const nextNameEl = document.getElementById(`${stationKey}-next-name`);
      const stationData = stations[stationKey];

      if (stationKey === "blood" && Array.isArray(stationData.current)) {
        if (stationData.current.length === 0) currentEl.textContent = "-";
        else if (stationData.current.length === 1)
          currentEl.textContent = stationData.current[0];
        else currentEl.innerHTML = stationData.current.join("<br>");
      } else {
        currentEl.textContent = stationData.current;
      }

      const isBloodTwoOrMore =
        stationKey === "blood" &&
        Array.isArray(stationData.current) &&
        stationData.current.length >= 2;
      if (timeEl) {
        timeEl.style.display = isBloodTwoOrMore ? "none" : "";
      }

      // 시간 타이머 관리
      if (stationData.active && stationData.startTime && !isBloodTwoOrMore) {
        // 시작 시간이 변경되었는지 확인
        if (cachedStartTimes[stationKey] !== stationData.startTime) {
          cachedStartTimes[stationKey] = stationData.startTime;
          startTimeTimer(
            stationKey,
            stationData.startTime,
            `${stationKey}-time`
          );
        }
      } else {
        // 검사가 끝났으면 타이머 정리
        stopTimeTimer(stationKey);
        timeEl.textContent = "-";
      }

      const nextText =
        stationData.next === "-" ? "대상자 없음" : stationData.next;
      if (nextNameEl) {
        nextNameEl.textContent = nextText;
      }
      station.classList.remove("active");
      if (stationData.active) {
        station.classList.add("active");
      }
    });
  }

  function updateNextSubject(nextUpData) {
    const nextSubjectEl = document.getElementById("next-subject-text");
    if (
      nextUpData &&
      nextUpData.snsbc &&
      Array.isArray(nextUpData.snsbc) &&
      nextUpData.snsbc.length > 0
    ) {
      const names = nextUpData.snsbc.join(", ");
      nextSubjectEl.innerHTML =
        '<span class="next-label">다음 </span><span class="next-name">' +
        names +
        "</span>";
    } else {
      nextSubjectEl.innerHTML =
        '<span class="next-label">다음 </span><span class="next-name">대상자 없음</span>';
    }
  }

  function loadSettings() {
    const savedSettings = localStorage.getItem("notificationSettings");
    if (savedSettings) {
      settings = { ...settings, ...JSON.parse(savedSettings) };
    }
    applySettingsToUI();
  }

  function applySettingsToUI() {
    document.getElementById("sound-snsbc").checked = settings.soundSnsbc;
    document.getElementById("tts-snsbc").checked = settings.ttsSnsbc;
    document.getElementById("sound-ecg").checked = settings.soundEcg;
    document.getElementById("sound-blood").checked = settings.soundBlood;
    document.getElementById("sound-physical").checked = settings.soundPhysical;
    const ttsEcgEl = document.getElementById("tts-ecg");
    if (ttsEcgEl) ttsEcgEl.checked = settings.ttsEcg;
    const ttsBloodEl = document.getElementById("tts-blood");
    if (ttsBloodEl) ttsBloodEl.checked = settings.ttsBlood;
    const ttsPhysicalEl = document.getElementById("tts-physical");
    if (ttsPhysicalEl) ttsPhysicalEl.checked = settings.ttsPhysical;
    document.getElementById("enable-all-sounds").checked =
      settings.enableAllSounds;
    document.getElementById("enable-all-tts").checked = settings.enableAllTts;
  }

  function openSettingsModal() {
    document.getElementById("settingsModal").style.display = "block";
    loadSettings();
    setupSettingsEventListeners();
  }

  function closeSettingsModal() {
    document.getElementById("settingsModal").style.display = "none";
  }

  function saveSettings() {
    settings.soundSnsbc = document.getElementById("sound-snsbc").checked;
    settings.ttsSnsbc = document.getElementById("tts-snsbc").checked;
    settings.soundEcg = document.getElementById("sound-ecg").checked;
    settings.soundBlood = document.getElementById("sound-blood").checked;
    settings.soundPhysical = document.getElementById("sound-physical").checked;
    const ttsEcgEl = document.getElementById("tts-ecg");
    if (ttsEcgEl) settings.ttsEcg = ttsEcgEl.checked;
    const ttsBloodEl = document.getElementById("tts-blood");
    if (ttsBloodEl) settings.ttsBlood = ttsBloodEl.checked;
    const ttsPhysicalEl = document.getElementById("tts-physical");
    if (ttsPhysicalEl) settings.ttsPhysical = ttsPhysicalEl.checked;
    settings.enableAllSounds =
      document.getElementById("enable-all-sounds").checked;
    settings.enableAllTts = document.getElementById("enable-all-tts").checked;
    localStorage.setItem("notificationSettings", JSON.stringify(settings));
    alert("설정이 저장되었습니다.");
    closeSettingsModal();
  }

  function resetSettings() {
    if (confirm("모든 설정을 초기화하시겠습니까?")) {
      settings = {
        soundSnsbc: true,
        ttsSnsbc: true,
        soundEcg: true,
        soundBlood: true,
        soundPhysical: true,
        ttsEcg: true,
        ttsBlood: true,
        ttsPhysical: true,
        enableAllSounds: true,
        enableAllTts: true,
      };
      localStorage.removeItem("notificationSettings");
      applySettingsToUI();
      alert("설정이 초기화되었습니다.");
    }
  }

  function testSound() {
    if (settings.enableAllSounds) {
      playSound(soundMap.A);
      setTimeout(() => {
        if (settings.enableAllTts) speak("최인규");
      }, 1000);
    } else {
      alert("알림음이 비활성화되어 있습니다.");
    }
  }

  function setupSettingsEventListeners() {
    const enableAllSounds = document.getElementById("enable-all-sounds");
    if (enableAllSounds) {
      enableAllSounds.addEventListener("change", function () {
        const isChecked = this.checked;
        document.getElementById("sound-snsbc").checked = isChecked;
        document.getElementById("sound-ecg").checked = isChecked;
        document.getElementById("sound-blood").checked = isChecked;
        document.getElementById("sound-physical").checked = isChecked;
      });
    }
    const enableAllTts = document.getElementById("enable-all-tts");
    if (enableAllTts) {
      enableAllTts.addEventListener("change", function () {
        document.getElementById("tts-snsbc").checked = this.checked;
        const ttsEcgEl = document.getElementById("tts-ecg");
        if (ttsEcgEl) ttsEcgEl.checked = this.checked;
        const ttsBloodEl = document.getElementById("tts-blood");
        if (ttsBloodEl) ttsBloodEl.checked = this.checked;
        const ttsPhysicalEl = document.getElementById("tts-physical");
        if (ttsPhysicalEl) ttsPhysicalEl.checked = this.checked;
      });
    }
  }

  window.onclick = function (event) {
    if (event.target === document.getElementById("settingsModal")) {
      closeSettingsModal();
    }
  };

  document.addEventListener("keydown", function (event) {
    if (event.key === "Escape") closeSettingsModal();
  });

  // 두 번째 화면용 데이터 렌더링 함수
  function renderData2(data) {
    const tableData = data.tableData;
    const nextUpData = data.nextUp;

    if (!tableData || tableData.length === 0) {
      document.getElementById("tableContainer2").innerHTML =
        "<p>표시할 데이터가 없습니다.</p>";
      return;
    }

    // 필요한 열만 표시하는 표 렌더링
    let html =
      '<table onclick="toggleScreen()" style="cursor: pointer;"><thead><tr>';
    tableData[0].forEach((header) => {
      html += `<th>${header}</th>`;
    });
    html += "</tr></thead><tbody>";

    for (let i = 1; i < tableData.length; i++) {
      const row = tableData[i];
      html += "<tr>";
      row.forEach((cell) => {
        html += `<td>${cell}</td>`;
      });
      html += "</tr>";
    }
    html += "</tbody></table>";

    document.getElementById("tableContainer2").innerHTML = html;
  }

  // === Firebase Integration ===
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "namwon-cohort.firebaseapp.com",
    databaseURL:
      "https://namwon-cohort-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "namwon-cohort",
    storageBucket: "namwon-cohort.firebasestorage.app",
    messagingSenderId: "214656200566",
    appId: "1:214656200566:web:b9f6c767faaab848aed457",
    measurementId: "G-3F35MSV0EM",
  };

  // Initialize Firebase
  firebase.initializeApp(firebaseConfig);
  const database = firebase.database();

  // Listen for data changes
  database.ref("cohortData").on("value", (snapshot) => {
    const data = snapshot.val();
    if (data) {
      // 데이터 구조가 GAS에서 보낸 것과 일치한다고 가정
      // GAS에서 { tableData: ..., nextUp: ... } 형태로 보낼 것임
      renderData(data);
      renderData2(data);
    }
  });

  // Initial load (optional, if we want to fetch once before Firebase connects, but Firebase usually caches)
  // fetchAndRender(); // Removed polling fetch

  loadSettings();

  // Removed setInterval polling

  document.addEventListener("click", function () {}, { once: true });
</script>
